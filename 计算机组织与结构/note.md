# 计算机组织与结构

<h4 align="right">秋水的复习笔记</h4>

<h5 align="right">作于 山东大学 软件学院 跨专业选修时期</h5>



## 前记





## 第一章　计算机系统概论



计算机硬件组成框图：

<img src="illus/image-20230104下午65304811.png" alt="image-20230104下午65304811" style="zoom:30%;" />



计算机硬件组成框图中各部件的作用：

- CPU 包括运算器和控制器两个部分：

    ALU 是运算器的核心器件，用来完成算术和逻辑运算

    CU是控制器的核心器件，用来解释存储器中的指令，并发出各种操作命令来执行指令

- 主存储器用来存放程序和数据，它可以直接与 CPU 交换信息

- I/O 设备受 CPU 控制，用来完成相应的输入输出操作



**Q1:  冯 · 诺依曼计算机的特点**

1. 计算机由运算器、控制器、存储器、输入设备、输出设备五大部件组成

2. 指令和数据以同等地位存于存储器，可按地址寻访

3. 指令和数据均用二进制数表示

4. 指令由操作码和地址码组成

5. 采用存储程序思想。指令在存储器内顺序存放，通常自动顺序取出执行

6. 机器以运算器为中心



**Q2:  计算机硬件的主要技术指标**

- 机器字长：CPU 一次能处理的数据的位数，通常与 CPU 寄存器的位数有关

- 存储容量：存储器中存放二进制代码的总位数，包含主存容量和辅存容量

    - 主存：存储单元个数$\times$存储字长 或 字节数

    - 辅存：字节数

- 运算速度：通常用MIPS、MFLOPS 或 CPI 来衡量



**Q3:  计算机区分存储器中的指令和数据的方式** 

1. 通过不同的时间段区分：

    在指令的取指阶段访存取出的是指令

    在指令的执行阶段访存取来的即为操作数，也就是数据

2. 通过不同的地址来源和目的地址区分：

    由 PC 提供访存地址，取来的即为指令，送往指令寄存器IR

    由指令的地址码部分提供访存地址取来的是操作数（数据），送往数据寄存器



## 第六章	计算机的运算方法



### 6.1 无符号数和有符号数



#### 6.1.1 无符号数

没有符号的数，寄存器中的每一位均可用来存放数值，表示范围在非负数域内



#### 6.1.2 有符号数

真值：带 $+ ,-$ 符号的数

机器数：把符号数字化的数，用逗号或小数点将符号位和数值位分隔开

- 原码：符号位 0 表正，1 表负
    $$
    \begin{align}
    \text{整数：}~~~~[x]_{\text 原} &= 
    \left\{
    \begin{array}{ll}
    ~0,x & 2^n>x\geqslant0 \\
    ~2^n-x & 0\geqslant x > -2^n
    \end{array}
    \right. \\~\\
    \text{小数：}~~~~[x]_{\text 原} &= 
    \left\{
    \begin{array}{ll}
    ~x & 1>x\geqslant0 \\
    ~1-x & 0\geqslant x > -1
    \end{array}
    \right.
    \end{align}
    $$
    
- 反码：原反相互转换，数值位取反末尾加 1
    $$
    \begin{align}
    \text{整数：}~~~~[x]_{\text 原} &= 
    \left\{
    \begin{array}{ll}
    ~0,x & 2^n>x\geqslant0 \\
    ~(2^{n+1}-1) + x & 0\geqslant x > -2^n & ( \text{ mod } (2^{n+1}-1)~)
    \end{array}
    \right. \\~\\
    \text{小数：}~~~~[x]_{\text 原} &= 
    \left\{
    \begin{array}{ll}
    ~x & 1>x\geqslant0 \\
    ~(2-2^{-n})+x & 0\geqslant x > -1 & ( \text{ mod } (2-2^{-n})~)
    \end{array}
    \right.
    \end{align}
    $$
    
- 补码：原补相互转换，负数数值位取反末尾加 1（反码加 1）
    $$
    \begin{align}
    \text{整数：}~~~~[x]_{\text 原} &= 
    \left\{
    \begin{array}{ll}
    ~0,x & 2^n>x\geqslant0 \\
    ~2^{n+1} + x & 0\geqslant x > -2^n & ( \text{ mod } 2^{n+1}~)
    \end{array}
    \right. \\~\\
    \text{小数：}~~~~[x]_{\text 原} &= 
    \left\{
    \begin{array}{ll}
    ~x & 1>x\geqslant0 \\
    ~2+x & 0\geqslant x \geqslant -1 & ( \text{ mod } 2~)
    \end{array}
    \right.
    \end{align}
    $$
    相反数的补码 $=$ 原数补码所有位按位取反吗末位加 1
    
- 移码：把负数映射到非负数域
    $$
    [x]_{\text{移}} = 2^n + x ~~~~(2^n > x \geqslant -2^n)
    $$
    移码和补码仅符号位相反



**Q1:  设机器字长为8位（含1位符号位在内），写出对应下列真值的原码、补码、反码**

- $-\cfrac{13}{64}$ 
    $$
    -\cfrac{13}{64} = - \cfrac{13}{2^6} = -(13)_{10} / 2^{6} = -(1101)_2/2^6=-0.001101 = x
    $$
    先移动小数点再算原反补
    $$
    [x]_原=1.0011010  ,~~  [x]_反=1.1100101 ,~~ [x]_补=1.1100110
    $$

- $\cfrac{29}{128}$
    $$
    \cfrac{29}{128} = \cfrac{29}{2^7} = (29)_{10} / 2^{7} = (11101)_2/2^7=0.0011101=x
    $$
    正数原反补相同
    $$
    [x]_原 = [x]_反 = [x]_补 = 0.0011101
    $$

- $-87$
    $$
    -87=-(87)_{10}=-(1010111)_2=- 1010111 = x
    $$
    同理可得
    $$
    [x]_原=1,1010111  ,~~  [x]_反=1,0101000 ,~~ [x]_补=1,0101001
    $$



**Q2:  当十六进制数 $\text{9BH}$ 和 $\text{FFH}$ 分别表示为原码、补码、反码、移码和无符号数时，所对应的十进制数各为多少（设机器数采用一位符号位）?**

- $(9B)_{16} = (10011011)_2$

    - 为原码

        $$
        x=(-11011)_2=(-27)_{10}
        $$

    - 为补码

        补码以 0 开头，说明真值是负数，补码数值位按位取反末尾加 1 得到原码
        $$
        [x]_原 = 1,1100101 \to x = (-1100101)_2=(-101)_{10}
        $$
    
    - 为反码
    
        反码以 0 开头，说明真值是负数，反码数值位按位取反得到原码
        $$
        [x]_原 = 1,1100100 \to x = (-1100100)_2=(-100)_{10}
        $$

    - 为移码

        移码符号位取反得到补码
        $$
        [x]_补 = 0,0011011
        $$
        补码以 0 开头，说明真值是正数，原反补相同
        $$
        [x]_原 = 0,0011011 \to x = (11011)_2 = (+27)_{10}
        $$
    
    - 为无符号数
    
        $$
        x = (10011011)_2 = (155)_{10}
        $$
    

- $(FF)_{16} = (11111111)_2$

    - 为原码

        $$
        x=(-1111111)_2=(-127)_{10}
        $$

    - 为补码

        补码以 0 开头，说明真值是负数，补码数值位按位取反末尾加 1 得到原码
        $$
        [x]_原 = 1,0000001 \to x = (-1)_2=(-1)_{10}
        $$
    
    - 为反码
    
        反码以 0 开头，说明真值是负数，反码数值位按位取反得到原码
        $$
        [x]_原 = 1,0000000 \to x = (-0)_2=(-0)_{10}
        $$

    - 为移码

        移码符号位取反得到补码
        $$
        [x]_补 = 0,1111111
        $$
        补码以 0 开头，说明真值是正数，原反补相同
        $$
        [x]_原 = 0,1111111 \to x = (1111111)_2 = (+127)_{10}
        $$
    
    - 为无符号数
    
        $$
        x = (11111111)_2 = (255)_{10}
        $$
    



### 6.2.1 数的定点表示和浮点表示

#### 6.2.1 定点表示









## 第四章　存储器



### 4.1 概述



#### 4.1.1 存储器的分类



|         分类方式 | 类内元素                                                     |
| ---------------: | ------------------------------------------------------------ |
|         存储介质 | （易失）半导体存储器<br />（非易失）磁表面存储器、磁芯存储器、光盘存储器 |
|         存取方式 | （随机访问）随机存储器、只读存储器<br />（串行访问）顺序存取存储器、直接存取存储器 |
| 在计算机中的作用 | <img src="illus/image-20230107下午81047847.png" alt="image-20230107下午81047847" style="zoom:25%;" /> |



#### 4.1.2 存储器的层次结构



**Q1:  存储器的层次结构及分层原因**

存储器的层次结构主要体现在下述两个存储层次上： 

1. Cache — 主存层次

    Cache — 主存层次主要解决 CPU 和主存速度不匹配的问题，在存储系统中主要对 CPU 访存起加速作用。从 CPU 的角度看，该层次的速度接近于 Cache，而容量和每位价格却接近于主存。这就解决了存储器的高速度和低成本之间的矛盾

2. 主存—辅存层次

    主存—辅存层次主要解决存储系统的容量问题，在存储系统中主要起扩容作用。从程序员的角度看，其所使用的存储器的容量和每位价格接近于辅存，而速度接近于主存。该层次解决了大容量和低成本之间的矛盾。



**Q2:  计算机管理存储器多级层次结构的方式**

主存 — Cache 之间的数据调度是由硬件自动完成的，对程序员是透明的

主存 — 辅存之间的数据调度，是由硬件和操作系统（采用虚拟存储技术）共同完成的



### 4.2 主存储器

#### 4.2.1 概述



主存的基本组成：

<img src="illus/image-20230107下午81929021.png" alt="image-20230107下午81929021" style="zoom:30%;" />

主寸和CPU的联系：

<img src="illus/image-20230107下午82017076.png" alt="image-20230107下午82017076" style="zoom:27%;" />

主存中存储单元地址的分配：大端法（大型机、小型机）、小端法（微机）

<img src="illus/image-20230107下午82338016.png" alt="image-20230107下午82338016" style="zoom:35%;" />

主存的技术指标：

- 存储容量：主存放二进制代码的总位数
    $$
    \begin{align}
    \text{存储容量} &= \text{存储单元个数} \times \text{存储字长} \\
    &= \text{存储单元个数} \times \text{存储字长／8} 	~\text{（用字节表示）}
    \end{align}
    $$

- 存储速度：由存取时间和存取周期来表示，一般存取周期大于存取时间
- 存储器带宽：单位时间内存储器存取的信息量



#### 4.2.2 半导体存储芯片简介



半导体存储芯片的基本结构

<img src="illus/image-20230107下午83530140.png" alt="image-20230107下午83530140" style="zoom:33%;" />

半导体存储芯片的译码驱动方式

|                            线选法                            |                            重合法                            |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| <img src="illus/image-20230107下午83818176.png" alt="image-20230107下午83818176" style="zoom:33%;" /> | <img src="illus/image-20230107下午83851016.png" alt="image-20230107下午83851016" style="zoom:33%;" /> |



#### 4.2.3 随机存取存储器



基本单元电路

| 静态RAM                                                      | 单管MOS动态RAM                                               |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| <img src="illus/image-20230107下午85510357.png" alt="image-20230107下午85510357" style="zoom:33%;" /> | <img src="illus/image-20230107下午85712198.png" alt="image-20230107下午85712198" style="zoom:20%;" /> |



**Q1:  比较静态RAM和动态RAM的特点**

- 静态RAM

    依靠双稳态触发器保存二进制代码，只要不断电，信息就不会丢失

    功耗较大，集成度较低，速度快，每位价格高，适合于作Cache或存取速度要求较高的小容量主存

- 动态RAM：

    依靠电容存储电荷来保存二进制代码，需刷新电路进行动态刷新，存取速度较慢

    功耗小，集成度高，每位价格低，适合于作大容量主存。



**Q2:  为什么要刷新**

- 主要原因是，由于电容极板漏抗的存在，存储于电容中的电荷存在泄漏的情况，这会导致动态RAM存储单元中的原存信息丢失。
- 此外，最常用的单管动态RAM的读出为破坏性读出。



**Q3:  动态RAM的几种不同刷新方式及特点**

- 集中式刷新

    在最大刷新间隔时间内，集中安排一段时间进行刷新。

    其缺点是进行刷新时必须停止读、写操作，这对主机而言是个“死区“ 

- 分散式刷新

    刷新工作安排在系统的存取周期内进行，对主机而言不再有“死区”。

    但该方式加长了系统的存取周期，存在无谓刷新，降低了整机运行效率。

    因此，分散方式刷新不适用于高速存储器。 

- 异步式刷新

    结合了上述两种方式的优点，充分利用了最大刷新间隔。

    相对于分散式刷新而言，它减少了刷新次数；相对于集中方式来说，主机的“死区”又缩短很多。

    因此，这种方式使用得比较多。

- 透明式刷新（可不答）

    该方式不占用CPU时间，对CPU而言是透明的操作；但控制线路复杂。



#### 4.2.5 存储器与CPU的连接



存储器的拓展：

- 位拓展：增加存储字长（例：2片 1K$\times$4 $\to$ 1K$\times$8）
- 字拓展：增加存储器字的数量（例：2片 1K$\times$8 $\to$ 2K$\times$8）
- 字、位拓展：既增加存储字的数量，又增加存储字长



**Q1:  某8位微型机地址码为18位，若使用4K×4位的RAM芯片组成模块板结构的存储器，试问：**

- **该机所允许的最大主存空间是多少？**
    $$
    2^{18} \times 8 \text{ bit} = 256\text{ KB}
    $$

- **若每个模块板为32K×8位，共需几个模块板？**
    $$
    \frac{256\text{ KB}}  {32\text{ KB}} = 8
    $$

- **每个模块板内共有几片RAM芯片？**
    $$
    \frac{32\text{ K} \times 8}  {4\text{ K} \times 4} = 16
    $$

- **共有多少片RAM？**
    $$
    8 \times 16 = 128
    $$

- **CPU如何选择各模块板？**

    $2^3$ 个模块板，需要最高 3 位地址译码选模板，板内 $2^3$ 组 $4 \text{K}\times 8$ RAM 需要次高 3 位地址译码选择 RAM 组，片内地址最高位译码选择两片 $4\text K \times 4$ 中的一片。



存储器与 CPU 的连接：

- 地址线 $\small A_0 -A_n$：低位接存储芯片，高位用于片选
- 数据线 $\small D_0 - D_m$：注意位拓展，数据位数应与数据线数相等
- 读/写命令线 $\small R/\overline W$
- 片选线 $\small \overline {CS}$：受到高位地址线、访存控制信号 $\small \overline{MREQ}$ 的控制



**Q2:  设 CPU 有 16 根地址线，8 根数据线，用 $\small \overline{MREQ}$（低电平有效）作访存控制信号，$\small R/\overline W$ 作读写控制信号（高电平为读，低电平为写），现有 1K×4 位、4K×8 位的 RAM 芯片，2K×8 位，4K×4 位的 ROM 芯片，以及 74138 译码器和各种门电路，画出 CPU 与存储器连接图，图中标明信号线的方向、种类和条数；并写出每片RAM芯片的地址范围（用十六进制描述)，要求：主存地址空间分配：A000H — A7FFH 为系统程序区； A800H — AFFFH为用户程序区。**

- 系统程序区用 ROM，A7FFH - A000H + 1 = 800H = 1000 0000 0000 = 2K，故选用 1 片 2K×8 ROM

    $2\text K= 2 ^{11}~~\longrightarrow~~$需要 11 根地址线连接

    1010 0<font color=Red>|</font>000 0000 0000

    1010 0<font color=Red>|</font>111 1111 1111

    CBA = 100 = 4 故接 $\overline {Y_4}$

- 用户程序区用 RAM，AFFFH - A800H + 1 = 800H = 1000 0000 0000 = 2K，故选用 4 片 1K×4 RAM

    每 2 个 1K×4 位拓展为 1K×8，两组 RAM 再字拓展为 2K×8

    $1\text K= 2 ^{10}~~\longrightarrow~~$各需要 10 根地址线连接

    RAM 芯片的地址范围：

    - RAM 1-2：A800H~ABFFH

        1010 1<font color=Red>|</font>0<font color=Blue>|</font>00 0000 0000

        1010 1<font color=Red>|</font>0<font color=Blue>|</font>11 1111 1111

        $A_{10}$ 为 0

    - RAM 3-4：AC00H~AFFFH

        1010 1<font color=Red>|</font>1<font color=Blue>|</font>00 0000 0000

        1010 1<font color=Red>|</font>1<font color=Blue>|</font>11 1111 1111

        $A_{10}$ 为 1

    CBA = 100 = 5 故接 $\overline {Y_5}$

<img src="illus/image-20230110上午13142521.png" alt="image-20230110上午13142521" style="zoom:30%;" />

注意点：

1. $\small \overline{MREQ}$ 要作为 74138 的其中一个控制信号输入
2. 对于 RAM，只接 10 根地址线，$A_{10}$ 参与片选
3. ROM 只读，RAM 双向读写



**Q3:  设 CPU 有 18 根地址线 (A17—A0)，8 根数据线 (D7—D0)，用 $\small \overline{MREQ}$ 做访存控制信号（低电平有效)，$\small R/\overline W$ 作读写控制信号（高电平为读，低电平为写)。现有下列芯片： 4K×8 位 RAM、2K×8 位 ROM 及 3 - 8 译码器和各种门电路。主存地址空间为：28800H 开始为 2K ROM，2E000H 开始为 8K RAM。要求：补充完成CPU与存储器连线图。**

<img src="illus/image-20230114下午35757676.png" alt="image-20230114下午35757676" style="zoom:28%;" />

- 8K RAM 选用 2 片 4K×8 芯片，各需要 12 根地址线

    2E000H + 8K - 1 = 2E000H + 2000H - 1 = 2FFFFH

    - RAM 1：2E000H~2EFFFH

        10 1110 <font color=Red>|</font> 0000 0000 0000

        10 1110 <font color=Red>|</font> 1111 1111 1111

        CBA = 110 = 6，故接 $\overline {Y_6}$

    - RAM 2：2F000H~2FFFFH

        10 1111 <font color=Red>|</font> 0000 0000 0000

        10 1111 <font color=Red>|</font> 1111 1111 1111

        CBA = 111 = 7，故接 $\overline {Y_7}$

- 2K ROM 选用 1 片 2K×8 芯片，需要 11 根地址线

    28800H + 2K - 1 = 28800H + 800H - 1 = 28FFFH

    10 1000 <font color=Red>|</font> 1<font color=Blue>|</font>000 0000 0000

    10 1000 <font color=Red>|</font> 1<font color=Blue>|</font>111 1111 1111

    CBA = 000 = 0，故接 $\overline {Y_0}$，同时要求 $A_{11}$ 为 1

<img src="illus/image-20230114下午40138489.png" alt="image-20230114下午40138489" style="zoom:30%;" />

注意点：

1. $\small \overline{MREQ}$ 仍要与高位地址线作与运算，作为 74138 的其中一个控制信号输入
2. 对于 ROM，只接 11 根地址线，$A_{11}$ 参与片选



#### 4.2.7 提高访存速度的措施

- 单体多字系统：增加存储器的带宽

    <img src="illus/image-20230114下午43913179.png" alt="image-20230114下午43913179" style="zoom:28%;" />

- 多体并行系统

    - 高位交叉：各个体并行工作，不同的请求源同时访问不同的体

        <img src="illus/image-20230114下午44130847.png" alt="image-20230114下午44130847" style="zoom:30%;" />

    - 低位交叉：各个体轮流编址 

        <img src="illus/image-20230114下午44229765.png" alt="image-20230114下午44229765" style="zoom:30%;" />

        在不改变存取周期的前提下，增加存储器的带宽，实现流水线方式存取

        <img src="illus/image-20230114下午44309641.png" alt="image-20230114下午44309641" style="zoom:28%;" />



### 4.3 高速缓冲存储器



#### 4.3.1 概述



Cache 存储器的理论依据：程序（或数据）访问的局部性原理

- 在一个较短的时间间隔内，CPU 对局部范围的存储器空间频繁访问，而对此地址范围之外的存储空间访问很少，这称为程序（或数据）访问的局部性。
- 设置 Cache 就是为了将主存的局部性数据块提前调度到 Cache 中，在较大命中率保证下，被CPU直接访问，而节省了访问主存的时间。



主存和缓存的编址：主存和缓存按块存储，块的大小相同

<img src="illus/image-20230114下午53027845.png" alt="image-20230114下午53027845" style="zoom:33%;" />



Cache 的命中率：CPU 欲访问的信息在 Cache 中的比率
$$
h = \frac {N_c} {N_c + N_m}
$$
$N_c$ 为访问 Cache 的总命中次数，$N_m$ 为访问主存的总次数



Cache — 主存系统的效率
$$
\begin{align}
e &= \frac {\text{访问 Cache 的时间}} {\text{平均访问时间}} \times 100\% \\
&= \frac {t_c}{h \times t_c + (1-h) \times t_m} \times 100\%
\end{align}
$$
$t_c$ 为命中时的 Cache 访问时间，$t_m$ 为未命中时的主存访问时间



Cache 的基本结构原理框图：由硬件自动完成，对用户透明

<img src="illus/image-20230114下午54431587.png" alt="image-20230114下午54431587" style="zoom:30%;" />



Cache 的读写操作：

- 读

    <img src="illus/image-20230114下午54618000.png" alt="image-20230114下午54618000" style="zoom:30%;" />

- 写

    - 写直达法：写操作时数据既写入 Cache 又写入主存
    - 写回法：写操作时只把数据写入 Cache 而不写入主存，当 Cache 数据被替换出去时才写回主存



#### 4.3.2 Cache—主存地址映射



- 直接映射：某一主存块只能固定映射到某一缓存块，简单但不够灵活
    $$
    i = j ~~\text {mod}~~ C    ~~~~\text{or}~~~~    i = j ~~\text {mod}~~ {2^c}
    $$
    <img src="illus/image-20230114下午60116267.png" alt="image-20230114下午60116267" style="zoom:22%;" />

    

- 全相连映射：某一主存块能映射到任一缓存块，灵活性大，结构复杂成本高

    <img src="illus/image-20230114下午60415945.png" alt="image-20230114下午60415945" style="zoom:20%;" />

    

- 组相连映射：某一主存块只能映射到某一缓存组中的任一块，性能与复杂性介于上述两种方式之间

    Cache 组数 Q，每组内有 $2^r$ 块，Cache 组号为 $j ~~\text{mod}~~Q$，组内编号 $k~(0 \leqslant k \leqslant 2^r - 1)$
    $$
    i = (j ~~\text {mod}~~ Q) \times 2^r + k
    $$
    <img src="illus/image-20230114下午95059346.png" alt="image-20230114下午95059346" style="zoom:20%;" />



**Q1:  设主存容量为 256K 字，Cache 容量为 2K 字，块长为 4。**

- **设计 Cache 地址格式，Cache 中可装入多少块数据？**
    $$
    \frac {2\text K} 4 = 2^9 = 512
    $$
    Cache 中可装入 512 个字块，需要 9 位地址，块内 $2^2$ 个字需要 2 位块内字地址，故 Cache 地址格式为

    <img src="illus/image-20230114下午102417903.png" alt="image-20230114下午102417903" style="zoom:26%;" />

    
    
- **在直接映射方式下，设计主存地址格式。**
    $$
    \frac {256\text{K}} {4} = 64 \text K = 2^{16}
    $$
    主存内共有 $2^{16}$ 个字块
    $$
    \frac {2^{16}}{2^9} = 2^7
    $$
    1 个 Cache 字块对应 $2^7$ 个主存字块，用于区分这 $2^7$ 个不同的主存字块的主存字块标记应为 7 位

    Cache 地址同上一小题，在前面增加主存字块标记，故主存地址格式为

    <img src="illus/image-20230114下午103907417.png" alt="image-20230114下午103907417" style="zoom:25%;" />
    
    
    
- **在四路组相联映射方式下，设计主存地址格式。**
    $$
    \frac {512} {4} = 128 = 2^7
    $$
    Cache 字块按 4 块一组分为 $2^7$ 组，共需要 7 位作为组地址
    $$
    \frac {2^{16}} {2^7} = 2^9
    $$
    1 个组对应 $2^9$ 个主存字块，同理主存字块标记应为 9 位，块内字地址 2 位，故主存地址格式为

    <img src="illus/image-20230114下午105621046.png" alt="image-20230114下午105621046" style="zoom:24%;" />



- **在全相联映射方式下，设计主存地址格式。**

    主存内共有 $2^{16}$ 个字块，1 个 Cache 字块可能对应 $2^{16}$ 个主存字块中的一个

    同理，主存字块标记应为 16 位，块内字地址 2 位，故主存地址格式为

    <img src="illus/image-20230114下午110412259.png" alt="image-20230114下午110412259" style="zoom:25%;" />

    

- **若存储字长为 32 位，存储器按字节寻址，写出八路组相联映射方式下主存的地址格式。**
    $$
    \frac {512} {8} = 64 = 2^6
    $$
    Cache 字块按 8 块一组分为 $2^6$ 组，共需要 6 位作为组地址
    $$
    \frac {2^{16}} {2^6} = 2^{10}
    $$
    1 个组对应 $2^{10}$ 个主存字块，同理主存字块标记应为 10 位
    $$
    \frac {4 \times 32} {8} = 16 = 2^4
    $$
    块内 4 个字对应 $2^4$ 个字节，按字节寻址需要 4 位作为块内字节地址，故主存地址格式为

    <img src="illus/image-20230114下午111129564.png" alt="image-20230114下午111129564" style="zoom:25%;" />



**Q2:  设主存容量为 1MB，采用直接映射方式的 Cache 容量为 16KB，块长为 4，每字 32 位。试问主存地址为 ABCDEH 的存储单元在 Cache 中的什么位置？**
$$
16 \text {K} = 2^{14} \\
4 \times \frac{32}8 = 16 = 2^4
$$
采用字节编址，Cache 的地址为 14 位，其中字块内地址为 4 位，Cache 字块地址为 $14-4=10$ 位

采用直接映射方式，主存地址后 14 位地址与 Cache 的 14 位地址相同

ABCDEH = 1010 10<font color=Red>11 1100 1101 1110</font>

后 14 位地址用十六进制描述为 3CDEH，这就是指定的主存单元在 Cache 中的位置



**Q:  设某机主存容量为 4MB，Cache 容量为 16KB，每字块有 8 个字，每字 32 位，设计一个四路组相联映射（即 Cache 每组内共有 4 个字块）的 Cache 组织。**

- **画出主存地址字段中各段的位数**
    $$
    \frac {16 \text K}  {4 \times 8} = 2 ^{9} \\
    \frac {2^9}{4} = 2^7
    $$
    1 个字 4 个 Byte，一个字块 8 个字，一组一共 4 个字块，Cache 共计 $2^7$ 组需要 7 位 Cache 组地址
    $$
    \frac {4 \text M}{4 \times 8} = 2^{17}
    $$
    同理，主存一共 $2^{17}$ 个字块，一个 Cache 组对应 $2^{10}$ 个主存字块，需要 10 位主存字块标记

    块内 $2^3$ 个字，需要 3 位块内字地址，故主存地址各字段位数为

    <img src="illus/image-20230119下午62349129.png" alt="image-20230119下午62349129" style="zoom:33%;" />

    

- **设 Cache 的初态为空，CPU 依次从主存第 0、1、2 …… 89 号单元读出 90 个字（主存一次读出一个字），并重复按此次序读 8 次，问命中率是多少？**
    $$
    \left\lceil \frac {90}{8}\right\rceil = 12 
    $$
    CPU 一次调出 1 个字块到 Cache，共有 12 次未命中，而后 7 次循全部命中，故命中率为
    $$
    \frac {90 \times 8 - 12}{90 \times 8} = 0.983
    $$
    
- **若 Cache 的速度是主存的 6 倍，试问有 Cache 和无 Cache 相比，速度约提高多少倍？**
    $$
    \text{速度比 =} \frac{1}{\text{时间比}}
    $$
	设 Cache 的存取周期为 t，则根据题意，主存的存取周期为 6t，则速度之比为

    $$
    \frac {6t \times 90 \times 8} {6t \times 12 + t \times (90 \times 8 - 12)} = 5.54
    $$
    



**Q4:  以全相联映射技术为例，说明在带有 Cache 的存储系统中，“读”操作是怎样完成的**

当 CPU 发出主存地址后，地址映射机构按照全相联映射方式将主存地址标记与 Cache 所有字块的标记进行比较，以判断出所访主存字（主存地址的内容）是否已在 Cache 中。

- 若命中，直接访问Cache，将该字送至CPU
- 若未命中
    - 一方面要访问主存，将该字传送给CPU
    - 与此同时，要按照全相联映射方式转换的 Cache 地址将该字所在的主存块装入 Cache
        - 如果此时 Cache 已装满，就要执行替换算法，腾出空位才能将新的主存块调入



某 Cache 共 32 个字块，每个字块有 32 个字，每个字为 32 位，采用 4 路组相联映射；存储器按字节编址，内存地址为 16 位，回答下述问题。

- Cache 地址各字段如何划分（各需多少位）
    $$
    \frac {32 \times 32}{8} = 2^7
    $$
    块内字节数为 $2^7$，需要 7 位块内字节地址
    $$
    32 = 2^5
    $$
    需要 5 位 Cache 字块地址

    

- 写出内存地址 375FH 可能映射成的 Cache 地址（用16进制表示）
    $$
    \frac {32}{4} = 2^3
    $$
    Cache 内一共有 $2^3$ 个组，主存地址需要 3 位 Cache 组地址
    $$
    16 - 7 - 3 = 6
    $$
    由主存 16 位地址计算得到主存字块标记为 6 位

    375FH = 0011 01<font color=Red>11 0</font>101 1111

    Cache 组地址为 110，组内地址 $5-3=2$ 位，故可能映射的 Cache 地址为

    ① 110 00 101 1111（十六进制：0C5FH ）

    ② 110 01 101 1111（十六进制：0CDFH ）

    ③ 110 10 101 1111（十六进制：0D5FH ）

    ④ 110 11 101 1111（十六进制：0DDFH ）

    

- 如果是二路组相联映射，计算主存 87 号（十进制）单元所在主存块应装入到的 Cache 组号
    $$
    \frac {32}{2} = 2^4
    $$
    Cache 内一共有 $2^4$ 个组，主存地址需要 4 位 Cache 组地址
    $$
    \left\lfloor\frac {87}{128}\right\rfloor = 0
    $$
    主存 87 号单元位于第 0 号字块
    $$
    i = j \text{ mod } Q = 0 \text{ mod } 16 = 0
    $$
    故主存 87 号单元映射到 Cache 的第 0 组

